# _Вариант 5_
## Группа 0
#### Вопрос 1: 
    Приведите компоненты Win API, необходимые для решения Лабораторной работы номер 3
Для решения лабораторной работы №3 были зайдейстованы следующие компоненты _**WinAPI**_: 
- Критические секции: InitializeCriticalSection, DeleteCriticalSection, EnterCriticalSection, LeaveCriticalSection
- События: CreateEvent, SetEvent, ResetEvent
- Потоки: CreateThread
- Функции ожидания: WaitForSingleObject, WaitForMultipleObjects (для массива HANDLE'ов)
#### Вопрос 2:
    Что такое поток в ОС Windows
**Потоком** в Windows называется объект ядра, которому операционная система выделяет процессорное
время для выполнения приложения. Каждому потоку принадлежат следующие ресурсы:
- код исполняемой функции;
- набор регистров процессора;
- стек для работы приложения;
- стек для работы операционной системы;
- блок окружения, который содержит служебную информацию для работы потока.

Пример создания потока:
```cpp
#include <windows.h>
#include <iostream>

using namespace std;

DWORD WINAPI ThreadProc(LPVOID lpParameter) {
    cout << "Thread is running" << endl;
    return 0;
}

int main() {
    HANDLE hThread;
    DWORD dwThreadId;

    hThread = CreateThread(
        NULL,
        0, 
        ThreadProc,
        NULL,              
        0,                 
        &dwThreadId);    

    if (hThread == NULL) {
        cout << "Failed to create thread" << endl;
        return 1;
    }

    cout << "Waiting for thread to finish..." << endl;

    WaitForSingleObject(hThread, INFINITE);

    cout << "Thread has finished" << endl;

    CloseHandle(hThread);

    return 0;
}
```

#### Вопрос 3:
    Что такое Мьютекс?
**Мьютекс** - объект ядра, который используется для решения проблемы взаимного исключения между параллельными потоками, выполняющиеся в контексте разных процессов. При этом, одновременно мьютекс может принадлежать одному потоку.

#### Вопрос 4:
    Что такое событие (объект синхронизации)?
**Событие** - это оповещение о некотором выполненном действии. События
используются для оповещения одного потока о том, что другой поток выполнил некоторое действие.
Позволяет решить задачу об условной синхронизации, или же задачей оповещения.

#### Вопрос 5:
Сравнительный анализ стандарта C++ 98 и любого более свежего стандарта (C++ 20)
|Функция|C++ 98|C++20|Описание|
|-------|------|-----|--------|
|Концепции|Нет|Да|Концепции позволяют программистам определять требования к шаблонам, что упрощает разработку и отладку кода|
|Модули|Нет|Да|Модули позволяют программистам организовывать код в логические блоки, что упрощает его использование и повторное использование|
|Инициализация|Ограниченные возможности|Новые возможности|C++20 включает в себя новые возможности для инициализации переменных, что упрощает написание кода|
|Константность|Ограниченные возможности|Новые возможности|C++20 включает в себя новые возможности для работы с константами, что упрощает написание кода|

### Группа 1 (Практическая часть)
#### Вопрос 1:
    На вход натуральное число n. На выход контейнер с первыми n факториалами.
[Ссылка на проект](https://github.com/animousen4/FactProj)
[Ссылка на перенесенный проект](https://github.com/animousen4/multithreading_projects/tree/main/colloquiums/FactorialN)
#### Вопрос 2:
    На вход – контейнер (массив) с числами. На выход контейнер, с неизменным списком элементов, но без дубликатов.
[Ссылка на проект](https://github.com/animousen4/multithreading_projects/tree/main/colloquiums/RemoveSameElements)
#### Вопрос 3:
    Развернуть связный список используя рекурсию.
[Ссылка на проект](https://github.com/animousen4/multithreading_projects/tree/main/colloquiums/ExpandLinkedList)

### Группа 2
#### Вопрос 1:
    Что такое ООП декомпозиция?
**Объектно-ориентированная декомпозиция** - это метод разбиения системы на модули, основанный на использовании объектов, или же их типов, как ключевых элементов архитектуры программных систем. Объектно-ориентированная декомпозиция позволяет достичь более высокого уровня абстракции, расширяемости, возможности повторного использования и согласованности.
#### Вопрос 2:
    Что такое статический полиморфизм?
Начнем с определения полиморфизма. **Полиморфизм** - это такое свойство, которое позволяет обрабатывать данные разных типов одним образом.
**Статический полиморфизм**, это такой полиморфизм, который не оказывает влияния на работу функции во время выполнения, но реализуется во время компиляции, а значит, что статический полиморфизм наиболее эффективен в отношении производительности.
#### Вопрос 3:
    Что такое инкапсуляция?
**Инкапсуляция** - это механизм, который позволяет скрыть внутреннюю реализацию объекта от внешнего мира и предоставить доступ к нему только через определенные методы. Это позволяет уменьшить связность между различными компонентами программы и упростить ее модификацию и сопровождение. 

Преимущества инкапсуляции:
- **Скрытие реализации**: Инкапсуляция позволяет скрыть внутреннюю реализацию объекта от внешнего мира, что делает код более понятным и упрощает его сопровождение.
- **Уменьшение связности**: Инкапсуляция позволяет уменьшить связность между различными компонентами программы, что упрощает ее модификацию и сопровождение.
- **Безопасность**: Инкапсуляция позволяет защитить данные объекта от неправильного использования (защита от "дурака"), что повышает безопасность программы.
- **Повторное использование**: Инкапсуляция позволяет повторно использовать объекты в различных частях программы, что уменьшает объем кода и упрощает его сопровождение.
- 
## Группа 3
    Builder паттерн
**Builder** - это порождающий паттерн проектирования, который позволяет создавать сложные объекты пошагово. Builder даёт возможность использовать один и тот же код строительства для получения разных представлений объектов. Также убирается необходимость в сложнейших конструкторах.
Паттерн Builder предлагает вынести конструирование объекта за пределы его собственного класса, поручив это дело отдельным объектам, называемым строителями.
Зачастую также применяется Director, который позволяет контролировать шаги строительства нашего объекта, а строитель же будет выполнять их. Такой подход также позволяет полностью скрыть от клиентского кода процесс конструирования объектов.
Примерная струтура Buider c Director с сайта _refactoring.guru_
![image](https://refactoring.guru/images/patterns/diagrams/builder/structure-indexed.png)

Таким образом, дизайн паттерн _Builder_ позволяет нам создание объектов пошагово, позволяет использовать один и тот же код для создания разных объектов, а также изолирует весь сложный процесс сборки объекта от основной логики.
Однако, имеются и _недостатки_ у такого паттерна, например, происходит сильное усложнение кода из-за дополнительных классов, а также клиент будет привязан к конкретным классам.

    Decorator паттерн
Декоратор — это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в «обёртки»
Декоратор позволяет нам не менять первоначальный класс и не создавать дочерних классов.Мы создаем класс, который в себя включает оригинальный класс (все так же неизменный), и получается, что мы можем дать дополнительные свойства, не изменяя основной класс

Применяется в основном, когда нам нужно добавить какое то дополнительное поведение объекта "налету". Поскольку обертка наша и объект имеют одинковый интерфейс, то по сути, клиентскому коду без разницы, с кем работать, с оберткой или самим уже объектом
Также применяется в случае, если заблокировано наследование от класса. И нам тут помогает как раз таки декоратор, который позволяет расширить его, не создавая наследуемых классов и не переделывая оригинальный.

Таким образорм, можно выделить следующие преимущества: гибкость, позволяет добавлять несколько поведений на один декоратор и несколько поведений на лету. А из недостатков можно выделить обилие небольших классов-декораторов, а также трудная конфигурация многократно обернутых классов